
#include <src/assets/icosphere.h>
#include "opengldemo.h"



OpenGLDemo::OpenGLDemo(int width, int height) : _width(width), _height(height), _drawfill(true)
        , _activecamera(0), _camera(nullptr)
        ,_shader{std::make_unique<Shader>("../shaders/phong_vs.glsl", "../shaders/phong_fs.glsl")}
        ,_colorShader{std::make_unique<Shader>("../shaders/color_vs.glsl", "../shaders/color_fs.glsl")}
        ,_selectedAsset{-1}
        ,waitingAssets{false}
        ,assetConstructor{nullptr}
{
    glEnable(GL_DEPTH_TEST);
    glViewport(0, 0, width, height);

    auto l = std::make_shared<PointLight>();
    lights.emplace_back(std::make_pair(l,new PointLightWidget(l)));


    _cameraselector.push_back( []()->Camera*{return new EulerCamera(glm::vec3(0.f, 0.f, 1.f));} );
    _cameraselector.push_back( []()->Camera*{return new TrackballCamera(glm::vec3(0.f, 0.f, 1.f),glm::vec3(0.f, 1.f, 0.f),glm::vec3(0.f, 0.f, 0.f));} );

    _camera.reset(_cameraselector[_activecamera]());

    _camera->setviewport(glm::vec4(0.f, 0.f, _width, _height));
    _view = _camera->viewmatrix();

    _projection = glm::perspective(_camera->zoom(), float(_width) / _height, 0.1f, 100.0f);
}




OpenGLDemo::~OpenGLDemo() {
}

void OpenGLDemo::resize(int width, int height) {
   _width = width;
   _height = height;
    _camera->setviewport(glm::vec4(0.f, 0.f, _width, _height));
    _projection = glm::perspective(_camera->zoom(), float(_width) / _height, 0.1f, 100.0f);
}

void OpenGLDemo::draw() {
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    _view = _camera->viewmatrix();
    _shader->use();
    _shader->setVec3("viewPos", _camera->position());
    _shader->setMat4("view",_view);
    _shader->setMat4("projection",_projection);

    if(waitingAssets){
        waitingAssets = false;
        createWaitingAssets();
    }
    for(auto &light : lights){
        light.first->addToShader(*_shader);
    }
    for(int i =0; i<assets.size();i++){
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        assets[i].first->drawAsset(*_shader);
        if(_selectedAsset == i){
            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
            glLineWidth(1);
            glEnable( GL_POLYGON_OFFSET_LINE );
            glPolygonOffset( -1, -1 );
            _colorShader->use();
            _colorShader->setMat4("view",_view);
            _colorShader->setMat4("projection",_projection);
            _colorShader->setVec3("color", glm::vec3(0.f, 1.f, 0.f));
            assets[i].first->drawAsset(*_colorShader);
            glDisable( GL_POLYGON_OFFSET_LINE );
            _shader->use();
        }
    }
    glDepthRange(0.0, 1.0);
    _shader->clearLights();
}

void OpenGLDemo::mouseclick(int button, float xpos, float ypos) {
    _button = button;
    _mousex = xpos;
    _mousey = ypos;
    _camera->processmouseclick(_button, xpos, ypos);
}

void OpenGLDemo::mousemove(float xpos, float ypos) {
    _camera->processmousemovement(_button, xpos, ypos, true);
}

void OpenGLDemo::keyboardmove(int key, double time) {
    _camera->processkeyboard(Camera_Movement(key), time);
}

bool OpenGLDemo::keyboard(unsigned char k) {
    switch(k) {
        case 'p':
            _activecamera = (_activecamera+1)%2;
            _camera.reset(_cameraselector[_activecamera]());
            _camera->setviewport(glm::vec4(0.f, 0.f, _width, _height));
            return true;
        case '+': {
            _selectedAsset = (_selectedAsset + 1) % assets.size();
            return true;
        }
        case '-': {
            _selectedAsset = (_selectedAsset - 1) % assets.size();
            return true;
        }

        default:
            return false;
    }
}

AssetInterface *OpenGLDemo::getSelection() {
    return assets[_selectedAsset].second;
}

void OpenGLDemo::toggledrawmode() {
    _drawfill = !_drawfill;
}

void OpenGLDemo::createNewSphere(){
    assetConstructor = []()->std::pair<std::shared_ptr<Asset>,AssetInterface*>{

        //auto textures = std::make_shared<DiffuseMap>("../textures/earth.jpg");
        auto sphere = std::make_shared<Sphere>();
        //sphere->getMesh(0)->addTexture(textures);
        return std::make_pair(sphere,new SphereWidget(sphere));
    };
    waitingAssets = true;
}

void OpenGLDemo::createNewIcoSphere(){
    assetConstructor = []()->std::pair<std::shared_ptr<Asset>,AssetInterface*>{
        auto sphere = std::make_shared<Icosphere>();
        return std::make_pair(sphere,new AssetInterface());
    };
    waitingAssets = true;
}



void OpenGLDemo::createImportedModel(const std::string &path) {
    assetConstructor = [path]()->std::pair<std::shared_ptr<Asset>,AssetInterface*>{
        auto  model = std::make_shared<AssimpMesh>(path);
        model->updateScale(0.1);
        return std::make_pair(model,new AssetInterface());
    };
    waitingAssets = true;

}

void OpenGLDemo::createWaitingModels() {
    assets.emplace_back(assetConstructor());
}

